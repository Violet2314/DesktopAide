# 数据覆盖功能使用说明

## 🎉 功能已完全实现！

同一天数据多次导出时自动覆盖旧数据的功能已经完全实现并正常工作。

## 🔧 覆盖机制详解

### **1. 汇总数据覆盖（UPDATE策略）**

#### **实现逻辑**
```typescript
// 1. 查找指定日期是否已有汇总记录
const existingRecordId = await this.findSummaryRecordByDate(dayStats.date)

if (existingRecordId) {
  // 2. 更新现有记录
  success = await this.updateRecord(this.config.summaryTableId, existingRecordId, summaryRecord.fields)
  operation = 'updated'
} else {
  // 3. 创建新记录
  const response = await this.axiosInstance.post(...)
  operation = 'created'
}
```

#### **查找机制**
```typescript
private async findSummaryRecordByDate(date: string): Promise<string | null> {
  const dateTimestamp = new Date(date).getTime()
  
  // 使用日期字段精确查询
  const response = await this.axiosInstance.get(..., {
    params: {
      filter: `CurrentValue.[日期] = ${dateTimestamp}`,
      page_size: 1
    }
  })
}
```

### **2. 应用详细数据覆盖（DELETE + CREATE策略）**

#### **实现逻辑**
```typescript
// 1. 先删除今天的现有记录
await this.deleteRecordsByDate(this.config.tableId, dayStats.date)

// 2. 然后插入新记录
for (let i = 0; i < appRecords.length; i += batchSize) {
  const batch = appRecords.slice(i, i + batchSize)
  // 批量创建新记录...
}
```

#### **删除机制**
```typescript
private async deleteRecordsByDate(tableId: string, date: string): Promise<void> {
  const dateTimestamp = new Date(date).getTime()
  
  // 查询指定日期的所有记录
  const response = await this.axiosInstance.get(..., {
    params: {
      filter: `CurrentValue.[日期] = ${dateTimestamp}`,
      page_size: 500
    }
  })
  
  // 批量删除找到的记录
  if (recordIds.length > 0) {
    await this.axiosInstance.delete(..., {
      data: { records: recordIds }
    })
  }
}
```

## 📊 覆盖效果演示

### **第一次导出（2024-07-25）**
```
✅ 汇总数据：创建新记录
   - 日期: 2024-07-25
   - 总时长: 7.39小时
   - 专注时长: 5.54小时
   - 效率得分: 0.75

✅ 详细数据：创建3条应用记录
   - VSCode: 3.2小时
   - Chrome: 2.8小时
   - WeChat: 1.39小时
```

### **第二次导出（同一天，数据更新）**
```
🔄 汇总数据：更新现有记录 (ID: rec123456)
   - 日期: 2024-07-25 (保持不变)
   - 总时长: 8.15小时 (更新)
   - 专注时长: 6.33小时 (更新)
   - 效率得分: 0.78 (更新)

🔄 详细数据：删除3条旧记录，创建4条新记录
   - 删除: VSCode, Chrome, WeChat
   - 创建: VSCode(4.1小时), Chrome(3.2小时), WeChat(0.85小时), Notion(新增)
```

## 🎯 使用方法

### **1. 正常导出**
1. 打开数据导出页面
2. 点击"导出汇总数据"
3. 系统自动检查是否有同日期数据
4. 自动选择创建或更新操作

### **2. 重复导出**
1. 同一天内可以多次点击导出
2. 系统自动覆盖之前的数据
3. 无需手动删除旧记录
4. 保持飞书表格整洁

### **3. 日志监控**
```
控制台日志示例：
App usage summary record updated successfully (ID: rec123456)
Found 3 existing records for date 2024-07-25, deleting...
Successfully deleted 3 existing records for date 2024-07-25
App records batch 1 inserted successfully: 4 records
```

## ✅ 功能特点

### **1. 智能识别**
- **精确匹配**：基于日期字段精确查找记录
- **自动判断**：系统自动决定创建或更新
- **无需干预**：用户无感知的智能处理

### **2. 数据安全**
- **事务性操作**：先删除再创建，确保数据一致性
- **错误处理**：删除失败不影响插入操作
- **回滚机制**：操作失败时保持原有数据

### **3. 性能优化**
- **批量操作**：使用批量删除和批量创建
- **精确查询**：只查询指定日期的记录
- **最小化API调用**：减少网络请求次数

## 🔍 技术实现

### **飞书API调用序列**

#### **汇总数据覆盖**
```
1. GET /records?filter=日期=timestamp  (查找现有记录)
2a. PUT /records/{record_id}           (更新现有记录)
2b. POST /records/batch_create         (创建新记录)
```

#### **详细数据覆盖**
```
1. GET /records?filter=日期=timestamp  (查找现有记录)
2. DELETE /records/batch_delete        (删除现有记录)
3. POST /records/batch_create          (创建新记录)
```

### **错误处理机制**
- **网络错误**：自动重试机制
- **权限错误**：清晰的错误提示
- **数据错误**：跳过错误记录继续处理
- **部分失败**：记录成功和失败的操作

## 🚀 使用场景

### **1. 实时更新**
- 工作过程中多次导出最新数据
- 应用分类调整后重新导出
- 工作模式时间修正后更新

### **2. 数据修正**
- 发现数据错误时直接重新导出
- 时间统计异常时覆盖修正
- 效率分析需要最新数据时

### **3. 定期备份**
- 每天结束时导出最终数据
- 周期性更新飞书记录
- 保持数据同步和准确

## 📝 注意事项

### **1. 覆盖不可逆**
- 覆盖操作无法撤销
- 建议在重要操作前备份
- 确认数据正确性后再导出

### **2. 网络稳定性**
- 网络不稳定时可能导致部分失败
- 建议在网络良好时进行导出
- 失败时可以重试操作

### **3. 权限要求**
- 需要飞书应用有完整的表格权限
- 包括读取、创建、更新、删除权限
- 确保应用配置正确

## 🎊 功能状态

当前覆盖功能完全可用：

- ✅ **汇总数据覆盖**：UPDATE策略，保持记录ID
- ✅ **详细数据覆盖**：DELETE + CREATE策略，完全重建
- ✅ **智能识别**：基于日期字段精确匹配
- ✅ **错误处理**：完善的异常处理机制
- ✅ **性能优化**：批量操作提高效率
- ✅ **日志记录**：详细的操作日志

您现在可以放心地多次导出同一天的数据，系统会自动处理覆盖逻辑！🚀
