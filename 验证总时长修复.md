# 总使用时长数据一致性修复

## 🔍 问题分析

### 原始问题
导出的总使用时长与应用追踪页面显示的总使用时长不一致。

### 根本原因
1. **前端显示**：使用`useRealTimeTimer`钩子的`realTimeTotalTime`
2. **飞书导出**：使用`calculateEfficiencyStats`函数重新计算的`totalTime`

### 数据流对比

#### 前端应用追踪页面
```
useRealTimeTimer.realTimeTotalTime
  ↓
= timerState.baseTotalTime + getCurrentAppDuration()
  ↓
显示在"总使用时长"卡片
```

#### 飞书导出（修复前）
```
AppTracker.getRealTimeUsageData()
  ↓
FeishuService.calculateEfficiencyStats(apps, dayStats)
  ↓
重新计算 totalTime = sum(app.duration)
  ↓
导出到飞书（数值不一致）
```

## ✅ 修复方案

### 1. 使用统一的总时长基准
```typescript
// 修复前：使用重新计算的totalTime
const totalHours = stats.totalTime / (1000 * 60 * 60)

// 修复后：使用dayStats.totalTime（与前端realTimeTotalTime对应）
const totalTime = dayStats.totalTime
const totalHours = totalTime / (1000 * 60 * 60)
```

### 2. 修正效率得分计算基准
```typescript
// 修复前：基于重新计算的stats.totalTime
const efficiencyScore = stats.totalTime > 0 ? Math.round((stats.productiveTime / stats.totalTime) * 100) : 0

// 修复后：基于dayStats.totalTime
const efficiencyScore = totalTime > 0 ? Math.round((stats.productiveTime / totalTime) * 100) : 0
```

### 3. 修正calculateEfficiencyStats函数
```typescript
// 修复前：总是重新计算totalTime
let totalTime = 0
Object.values(apps).forEach((app: any) => {
  totalTime += app.duration
})

// 修复后：优先使用usageData.totalTime
if (usageData && usageData.workModeTime > 0) {
  const realTotalTime = usageData.totalTime || totalTime
  // 使用实际的总时长
  totalTime = realTotalTime
}
```

## 📊 数据对应关系（修复后）

| 数据源 | 计算方式 | 用途 |
|--------|----------|------|
| `useRealTimeTimer.realTimeTotalTime` | `baseTotalTime + currentAppDuration` | 前端显示 |
| `AppTracker.getRealTimeUsageData().totalTime` | `todayData.totalTime + currentAppDuration` | 飞书导出 |
| **结果** | **两者应该完全一致** | **数据一致性** |

## 🧪 验证方法

### 手动验证步骤
1. 打开应用追踪页面
2. 记录"总使用时长"显示的数值（如：07:23:14）
3. 立即导出汇总数据到飞书
4. 检查飞书表格中的"总时长"字段
5. 验证：前端显示时长 = 飞书总时长 × 3600000ms

### 预期结果
```
前端显示：07:23:14 (26594822ms = 7.39小时)
飞书导出：7.39小时
验证：26594822 ÷ 3600000 = 7.39 ✅
```

## 🔧 技术细节

### AppTracker.getRealTimeUsageData()
```typescript
// 返回包含当前应用实时时间的数据
const realTimeData = { ...this.todayData }
if (this.currentApp && this.currentAppStartTime > 0) {
  const currentAppDuration = Date.now() - this.currentAppStartTime
  // 更新总时间
  realTimeData.totalTime += currentAppDuration
}
return realTimeData
```

### useRealTimeTimer.getRealTimeTotalTime()
```typescript
// 计算实时总时长
const getRealTimeTotalTime = useCallback(() => {
  return timerState.baseTotalTime + getCurrentAppDuration()
}, [timerState.baseTotalTime, getCurrentAppDuration])
```

### 一致性保证
两个计算方式都是：**保存的总时长 + 当前应用实时时长**

## 📝 修复清单

- [x] **统一总时长基准**：使用`dayStats.totalTime`而不是重新计算
- [x] **修正效率得分计算**：基于统一的总时长计算
- [x] **更新calculateEfficiencyStats**：优先使用传入的总时长
- [x] **保持其他逻辑不变**：专注时长、分心时长计算逻辑保持一致
- [x] **添加调试日志**：便于验证修复效果

## 🎯 验证要点

### 关键数值对比
1. **总时长一致性**：前端显示 = 飞书导出
2. **效率得分准确性**：基于正确的总时长计算
3. **专注/分心时长**：计算逻辑保持不变
4. **实时性**：包含当前应用的实时时间

### 调试日志示例
```
App usage summary - dayStats: {
  totalTime: 26594822,  // 这个值应该与前端realTimeTotalTime一致
  workModeTime: 433682,
  appsCount: 3
}
App usage summary - final data: {
  totalHours: 7.39,     // 这个值应该与前端显示一致
  productiveHours: 1.77,
  distractingHours: 0.09,
  efficiencyScore: "93%"
}
```

## 🚀 测试建议

1. **重启应用程序**：确保修复生效
2. **使用一段时间**：积累一些使用数据
3. **对比验证**：前端显示 vs 飞书导出
4. **多次测试**：确保一致性稳定

现在总使用时长应该完全一致了！🎉
