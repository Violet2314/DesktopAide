# 数据导出一致性验证

## 🎯 问题分析

### 原始问题
导出的汇总数据与应用追踪页面显示的数据不一致，主要原因：

1. **数据源不同**：
   - 应用追踪页面：使用实时数据（`getRealTimeUsageData()`）
   - 飞书导出：使用保存的数据（`getUsageData()`）

2. **计算逻辑不同**：
   - 应用追踪页面：包含工作模式时间的复杂计算逻辑
   - 飞书导出：简化的应用分类计算逻辑

3. **时间基准不同**：
   - 应用追踪页面：`realTimeTotalTime`（包含当前应用实时时间）
   - 飞书导出：`dayStats.totalTime`（保存的总时间）

## ✅ 解决方案

### 1. 统一数据源
```typescript
// DataExportManager.ts - 更新后
if (targetDate === today) {
  // 对于今天的数据，使用实时数据（包含当前应用的实时时间）
  dayStats = this.appTracker.getRealTimeUsageData()
} else {
  // 对于历史数据，使用保存的数据
  dayStats = this.appTracker.getUsageData(targetDate)
}
```

### 2. 统一计算逻辑
```typescript
// FeishuService.ts - 更新后
private calculateEfficiencyStats(apps: { [key: string]: any }, usageData?: any) {
  // 与前端AppContext中的逻辑完全一致
  // 包含工作模式时间的处理逻辑
  if (usageData && usageData.workModeTime > 0) {
    // 工作模式时间直接替换为高效时间
    productiveTime = usageData.workModeTime
    // ... 复杂的重新分配逻辑
  }
}
```

### 3. 统一效率得分格式
```typescript
// 前端AppContext：返回百分比整数（如75表示75%）
const efficiencyScore = totalTime > 0 ? Math.round((productiveTime / totalTime) * 100) : 0

// 飞书导出：保持一致
const efficiencyScore = stats.totalTime > 0 ? Math.round((stats.productiveTime / stats.totalTime) * 100) : 0
```

## 📊 数据流对比

### 应用追踪页面数据流
```
AppTracker.getRealTimeUsageData()
  ↓ (包含当前应用实时时间)
AppContext.getEfficiencyStats(realTimeApps, realTimeUsageData)
  ↓ (包含工作模式时间处理)
显示统计卡片：
- 总使用时长: realTimeTotalTime
- 高效时长: stats.productiveTime
- 分心时长: stats.distractingTime  
- 效率得分: stats.efficiencyScore%
```

### 飞书导出数据流（更新后）
```
AppTracker.getRealTimeUsageData() (今天) / getUsageData() (历史)
  ↓ (相同的数据源)
FeishuService.calculateEfficiencyStats(apps, usageData)
  ↓ (相同的计算逻辑)
导出汇总记录：
- 总时长: stats.totalTime (小时)
- 专注时长: stats.productiveTime (小时)
- 分心时长: stats.distractingTime (小时)
- 效率得分: efficiencyScore (百分比整数)
```

## 🔍 关键改进点

### 1. 数据源统一
- ✅ 今天的数据：使用`getRealTimeUsageData()`
- ✅ 历史数据：使用`getUsageData(date)`
- ✅ 确保包含当前应用的实时时间

### 2. 计算逻辑统一
- ✅ 复制AppContext中的完整`getEfficiencyStats`逻辑
- ✅ 包含工作模式时间的特殊处理
- ✅ 相同的应用分类规则

### 3. 格式统一
- ✅ 效率得分：百分比整数格式
- ✅ 时长：小时单位，保留2位小数
- ✅ 与前端显示格式完全一致

## 🧪 验证方法

### 手动验证步骤
1. 打开应用追踪页面，记录显示的统计数据
2. 立即导出汇总数据到飞书
3. 对比两者的数值是否一致

### 预期结果
- **总时长**：应用追踪页面的"总使用时长" = 飞书"总时长" × 3600000ms
- **专注时长**：应用追踪页面的"高效时长" = 飞书"专注时长" × 3600000ms  
- **分心时长**：应用追踪页面的"分心时长" = 飞书"分心时长" × 3600000ms
- **效率得分**：应用追踪页面的"效率得分" = 飞书"效率得分"

### 调试日志
更新后的代码包含详细的调试日志：
```typescript
console.log('App usage summary - dayStats:', {
  totalTime: dayStats.totalTime,
  workModeTime: dayStats.workModeTime,
  appsCount: Object.keys(dayStats.apps).length
})
console.log('App usage summary - calculated stats:', stats)
console.log('App usage summary - final data:', {
  totalHours,
  productiveHours,
  distractingHours,
  efficiencyScore: efficiencyScore + '%'
})
```

## 🎯 测试场景

### 场景1：无工作模式时间
- 应用分类计算：开发工具+工作效率 = 专注时长
- 娱乐+通讯社交 = 分心时长

### 场景2：有工作模式时间
- 工作模式时间 = 专注时长基础值
- 非工作模式时间按应用分类重新分配

### 场景3：实时数据
- 包含当前正在使用的应用时间
- 如果当前在工作模式，实时时间计入工作模式时间

## ✅ 验证清单

- [x] 数据源统一（实时数据 vs 保存数据）
- [x] 计算逻辑统一（工作模式时间处理）
- [x] 效率得分格式统一（百分比整数）
- [x] 时长单位统一（毫秒 vs 小时）
- [x] 调试日志完善
- [x] 错误处理完善

## 🚀 部署验证

更新完成后，建议：
1. 重启应用程序
2. 使用一段时间积累数据
3. 对比应用追踪页面和飞书导出的数据
4. 验证数据一致性

现在导出的汇总数据应该与应用追踪页面显示的数据完全一致！
